<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>mdm.jl ¬∑ RiemannianML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="RiemannianML logo"/></a><h1>RiemannianML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">RiemannianML Documentation</a></li><li><a class="toctext" href="../MainModule/">MainModule (RiemannianML.jl)</a></li><li><a class="toctext" href="../knn/">knn.jl</a></li><li><a class="toctext" href="../logisticRegression/">logisticRegression.jl</a></li><li><a class="toctext" href="../SVM/">SVM.jl</a></li><li><a class="toctext" href="../train_test/">train_test.jl</a></li><li class="current"><a class="toctext" href>mdm.jl</a><ul class="internal"><li><a class="toctext" href="#MDM-structure-1">MDM structure</a></li><li><a class="toctext" href="#mean_mdm-1">mean_mdm</a></li><li><a class="toctext" href="#find_dist-1">find_dist</a></li><li><a class="toctext" href="#predict_mdm-1">predict_mdm</a></li><li><a class="toctext" href="#predict_prob-1">predict_prob</a></li><li><a class="toctext" href="#indCV-1">indCV</a></li><li><a class="toctext" href="#cross*val*mdm-1">cross<em>val</em>mdm</a></li></ul></li><li><a class="toctext" href="../example/">example.jl</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>mdm.jl</a></li></ul><a class="edit-page" href="https://github.com/tosalonijain/RiemannianML/blob/master/docs/src/mdm.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>mdm.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="mdm.jl-1" href="#mdm.jl-1">mdm.jl</a></h1><p>This unit implemets the <strong>MDM (Minimum Distance to Mean)</strong> classifier for the manifold of positive definite matrices. Similarly to what is done in ScikitLearn in Python, a type is created (struct in Julia) of the desired specifications.  It also implements <strong>cross validation algorithm for MDM</strong>( Minimum Distance to Mean) classifier again similar to ScikitLearn in Python, one can have a better evaluation of the classifier by using cross validation. Module incorporates supporting functions :   <strong>find_dist</strong>,    <strong>predict_mdm</strong>,    <strong>predict_prob</strong>,   <strong>indCV</strong>.</p><p>It implemens a structure <strong>MDM</strong> and includes the following functions :</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#RiemannianML.mean_mdm"><code>mean_mdm</code></a></td><td style="text-align: left">calculates the mean of all the classes in the training set and also    		 		notifies the user if the mean is not convergent in case of some metric 				spaces</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.find_dist"><code>find_dist</code></a></td><td style="text-align: left">finds the distance of each sample case from the so found means of all the classes</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.predict_mdm"><code>predict_mdm</code></a></td><td style="text-align: left">predicts the class for each sample case depending on its distance from the respective means</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.predict_prob"><code>predict_prob</code></a></td><td style="text-align: left">predicts the probability of each class for each sample case depending on its distance from the respective means</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.indCV"><code>indCV</code></a></td><td style="text-align: left">returns the vectors containing shuffled indices of training and testing samples for each cross validation iteration</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.cross_val_mdm"><code>cross_val_mdm</code></a></td><td style="text-align: left">implements cross validation for MDM classifier</td></tr></table><p>For a detailed understanding of mdm, one should know the basics of Riemannian Geometry and its application in the classification of positive definite matrices. One may refer to the following papers for getting the feel of the process.</p><p>A. Barachant, S. Bonnet, M. Congedo, C. Jutten (2012)<a href="../#-1">üéì</a></p><p>A. Barachant, S. Bonnet, M. Congedo, C. Jutten (2013)<a href="../#-1">üéì</a></p><p>M. Congedo, A. Barachant, R. Bhatia R (2017a)<a href="../#-1">üéì</a></p><p>M. Congedo, A. Barachant, E. Kharati Koopaei (2017b)<a href="../#-1">üéì</a></p><p>Or one may directly look into the <a href="https://marco-congedo.github.io/PosDefManifold.jl/latest/introToRiemannianGeometry/">Intro to Riemannian Geometry</a> section of the PostDefManifold documentation and quench all their doubts. </p><h2><a class="nav-anchor" id="MDM-structure-1" href="#MDM-structure-1">MDM structure</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.MDM" href="#RiemannianML.MDM"><code>RiemannianML.MDM</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>This is a structure of the MDM model. It has two attributes namely metric and class_means.</p><ul><li><code>metric :: Metric</code>        :- The user needs to specify the metric space in which all the distance computations is to be done. The possible options are:</li></ul><table><tr><th style="text-align: left">Metric</th><th style="text-align: left">Mean estimation</th></tr><tr><td style="text-align: left">Euclidean</td><td style="text-align: left">distance: Œ¥_e; mean: Arithmetic</td></tr><tr><td style="text-align: left">invEuclidean</td><td style="text-align: left">distance: Œ¥_i; mean: Harmonic</td></tr><tr><td style="text-align: left">ChoEuclidean</td><td style="text-align: left">distance: Œ¥_c; mean: Cholesky Euclidean</td></tr><tr><td style="text-align: left">logEuclidean</td><td style="text-align: left">distance: Œ¥_l; mean: Log Euclidean</td></tr><tr><td style="text-align: left">logCholesky</td><td style="text-align: left">distance: Œ¥_c; mean: Log-Cholesky</td></tr><tr><td style="text-align: left">Fisher</td><td style="text-align: left">distance: Œ¥_f; mean: Fisher (Cartan, Karcher, Pusz-Woronowicz,...)</td></tr><tr><td style="text-align: left">logdet0</td><td style="text-align: left">distance: Œ¥_s; mean: LogDet (S, Œ±, Bhattacharyya, Jensen,...)</td></tr><tr><td style="text-align: left">Jeffrey</td><td style="text-align: left">distance: Œ¥_j; mean: Jeffrey (symmetrized Kullback-Leibler)</td></tr><tr><td style="text-align: left">VonNeumann</td><td style="text-align: left">distance: Œ¥_v; mean: Not Availale</td></tr><tr><td style="text-align: left">Wasserstein</td><td style="text-align: left">distance: Œ¥_w; mean: Wasserstein (Bures, Hellinger, ...)</td></tr></table><ul><li><code>class_means</code>             :- This is not to be specified by the user. This comes to play when                               a model is fit with a set of training data so we have to store the means corresponding                               to each of the classes. We can directly access this for an already fit model                               while using functions like predict.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L3-L28">source</a></section><h2><a class="nav-anchor" id="mean_mdm-1" href="#mean_mdm-1">mean_mdm</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.mean_mdm" href="#RiemannianML.mean_mdm"><code>RiemannianML.mean_mdm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Given a metric, ‚ÑçVector( Vector of Hermitian matrices), weights(optional) returns the mean of these Hermitian matrices for mdm classifier.This function is kind of an interface to the mean function of PostDefManifold. Refer to the <a href="https://marco-congedo.github.io/PosDefManifold.jl/latest/riemannianGeometry/#Means-1">Mean</a> of PosDefManifold.</p><p>Arguments :</p><ul><li><code>metric :: Metric</code>        :-The user needs to specify the metric space in which                               all the distance computations is to be done.</li><li><code>ùêè::‚ÑçVector</code>              :-Vector of Hermitian matrices or simply a HermitianVector.                                    The vector of points in the <em>Symmetric Positive Definite</em>                                    manifold to be transformed into the the tangent space.</li><li><code>w::Vector(optional)</code>:- Vector containing weights corresponding to every point in ùêè.</li><li><code>‚úìw = true(optional)</code>    :- Boolean to determine whether to calculate weighted mean or                                just take w = []. It also checks if the weights                                sum up to 1. If not does normalization.</li><li><code>‚è© = false (optional)</code>   :- Boolean to allow threading or not.</li></ul><p>Returns :</p><ul><li><code>G :: ‚Ñç</code>                  :- Mean of the set of ‚ÑçVector.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L38-L63">source</a></section><h2><a class="nav-anchor" id="find_dist-1" href="#find_dist-1">find_dist</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.find_dist" href="#RiemannianML.find_dist"><code>RiemannianML.find_dist</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Given a sample set, class<em>means, type of metric returns the distance of each sample case from the points in class</em>means. Distance should be caluclated in the metric space opted by the user while creating the instance of mdm.</p><p>Arguments :</p><ul><li><code>sample :: ‚ÑçVector</code>       :-The vector of Hermitian matrices or points in                                      the positive definite manifold for which the                                      prediction is to be made using the model(argument 1)                                      already been trained specially for it.</li><li><code>class_means</code>             :- Vector of Hermitian matrices that represent the class                               means or the centroid of all the classes in the training set.</li><li><code>metric :: Metric</code>        :-The user needs to specify the metric space in which                               all the distance computations is to be done.</li></ul><p>Return :</p><ul><li><code>A :: Array{Float64,2}</code>   :- Array of distances of each of the sample case from                                   each of the class_means.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L99-L121">source</a></section><h2><a class="nav-anchor" id="predict_mdm-1" href="#predict_mdm-1">predict_mdm</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.predict_mdm" href="#RiemannianML.predict_mdm"><code>RiemannianML.predict_mdm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Given a sample set, class_means, type of metric returns the predicted classes for each sample case according to the Minimum Distance to the Means scheme.</p><p>Arguments :</p><ul><li><code>sample :: ‚ÑçVector</code>       :- The vector of Hermitian matrices or points in                                          the positive definite manifold for which the                                          prediction is to be made using the model(argument 1)                                          already been trained specially for it.</li><li><code>class_means</code>             :- Vector of Hermitian matrices that represent the class                                   means or the centroid of all the classes in the training set.</li><li><code>metric :: Metric</code>        :- The user needs to specify the metric space in which                               all the distance computations is to be done.</li></ul><p>Returns :</p><ul><li><code>result :: Array{Int, 1}</code> :- The List of the predicted classes for the given                                   sample set.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L131-L152">source</a></section><h2><a class="nav-anchor" id="predict_prob-1" href="#predict_prob-1">predict_prob</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.predict_prob" href="#RiemannianML.predict_prob"><code>RiemannianML.predict_prob</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Given a sample set, class_means, type of metric returns the probability of each class for each sample case according to the Minimum Distance to the Means scheme. All the probability sums to 1. This function makes use of the softmax function from thr PostDefManifold to calculate the probability values.</p><p>Arguments :</p><ul><li><code>sample :: ‚ÑçVector</code>       :-The vector of Hermitian matrices or points in                                          the positive definite manifold for which the probability                                          prediction is to be made using the model(argument 1)                                          already been trained specially for it.</li><li><code>class_means</code>             :- Vector of Hermitian matrices that represent the class                                   means or the centroid of all the classes in the training set.</li><li><code>metric :: Metric</code>        :-The user needs to specify the metric space in which                               all the distance computations is to be done.</li></ul><p>Returns :</p><ul><li><code>Prob :: Array{Float64,1}</code>:- The List of the predicted probabilities corresponding                                   to each of the classes for the given sample set.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L161-L185">source</a></section><h2><a class="nav-anchor" id="indCV-1" href="#indCV-1">indCV</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.indCV" href="#RiemannianML.indCV"><code>RiemannianML.indCV</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Given the length, nCV( number of cross-validations) returns the vectors containing indices of training and testing samples for each cross validation iteration. This is a helper function to implement cross<em>val</em>mdm. It uses shuffle! of the Random.jl package. This function holds the prime basis of CrossValidation implementation.</p><p>Arguments :</p><ul><li><code>k::Int</code>                 :- Last number of the sequence of natural numbers to be                                   shuffled starting from 1</li><li><code>nCV:: Int</code>              :- Number of cross-validation for which the indices are                                   to be generated.</li><li><code>shuffle</code>                :- Boolean to inform whether to do shuffling or not.                                Default is set to True.</li></ul><p>Returns :</p><ul><li><code>nTest</code>                  :- The size of each testing set.</li><li><code>nTrain</code>                 :- The size of each training set.</li><li><code>indTrain</code>               :- The list of all the vectors that contain the training                                   indices for each iteration.</li><li><code>indTest</code>                :- The list of all the vectors that contain the testing                                   indices for each iteration.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L194-L220">source</a></section><h2><a class="nav-anchor" id="cross*val*mdm-1" href="#cross*val*mdm-1">cross<em>val</em>mdm</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.cross_val_mdm" href="#RiemannianML.cross_val_mdm"><code>RiemannianML.cross_val_mdm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>Given a ‚ÑçVector(training set), y(labels), cv(number of cross-validations) returns the the list containing the score for each cross-validation iteration. The score may be average balanced accuracy or average regular accuracy depending on the choice of the user. *It is better to call for balanced accuracy as a better estimation of the model performance. Overall, if the number of ases in for each class are same, balanced accuracy equals the regular accuracy.</p><p>This is the main function implementing cross validation for MDM classifier. It uses indCV as its basic helper function. It also returns the final confusion matrix.</p><p>Arguments :</p><ul><li><code>ùêó :: ‚ÑçVector</code>          :- The training set of type Vector of Hermitian matrices.</li><li><code>y</code>                      :- The list of labels corresponding to each trial</li><li><code>cv :: Int</code>              :- The number of cross-validation desired by the user</li><li><code>scoring :: String</code>      :- If Balanced Accuracy is requied or the Regular Accuracy.                                   The default is set to Balanced Accuracy.</li><li><code>metric :: Metric</code>       :- The metric space in which to do the computations. To be                                   specified by the user as one of the many metric spaces options provided in PostDefManifold.                                   One may refer to [mdm.jl documentations] for exploring all the possible options.                                   The default is set to Fisher.</li><li><code>cnfmat :: Bool</code>         :- Boolean to notify if the user wants the confusion matrix also.                              Default is set to false.</li></ul><p>Returns :</p><ul><li><code>cross_val score</code>       :- The list of the balanced accuracy score for each                               cross_val iteration.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/mdm.jl#L242-L274">source</a></section><footer><hr/><a class="previous" href="../train_test/"><span class="direction">Previous</span><span class="title">train_test.jl</span></a><a class="next" href="../example/"><span class="direction">Next</span><span class="title">example.jl</span></a></footer></article></body></html>
