<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>mdm.jl ¬∑ RiemannianML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RiemannianML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">RiemannianML Documentation</a></li><li><a class="toctext" href="../MainModule/">MainModule (RiemannianML.jl)</a></li><li><a class="toctext" href="../knn/">knn.jl</a></li><li><a class="toctext" href="../logisticRegression/">logisticRegression.jl</a></li><li><a class="toctext" href="../SVM/">SVM.jl</a></li><li><a class="toctext" href="../train_test/">train_test.jl</a></li><li class="current"><a class="toctext" href>mdm.jl</a><ul class="internal"><li><a class="toctext" href="#MDM-structure-1">MDM structure</a></li><li><a class="toctext" href="#mean_mdm-1">mean_mdm</a></li><li><a class="toctext" href="#find_dist-1">find_dist</a></li><li><a class="toctext" href="#predict_mdm-1">predict_mdm</a></li><li><a class="toctext" href="#predict_prob-1">predict_prob</a></li></ul></li><li><a class="toctext" href="../cross_mdm/">cross_mdm.jl</a></li><li><a class="toctext" href="../example/">example.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>mdm.jl</a></li></ul></nav><hr/><div id="topbar"><span>mdm.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="mdm.jl-1" href="#mdm.jl-1">mdm.jl</a></h1><p>This unit implemets the <strong>MDM (Minimum Distance to Mean)</strong> classifier for the manifold of positive definite matrices. Similarly to what is done in ScikitLearn in Python, a type is created (struct in Julia) of the desired specifications. Module incorporates supporting functions :   <strong>find<em>dist,   predict</em>mdm,   predict_prob</strong>.</p><p>It implemens a structure <strong>MDM</strong> and includes the following functions :</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#RiemannianML.mean_mdm"><code>mean_mdm</code></a></td><td style="text-align: left">calculates the mean of all the classes in the training set and also    		 		notifies the user if the mean is not convergent in case of some metric 				spaces</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.find_dist"><code>find_dist</code></a></td><td style="text-align: left">finds the distance of each sample case from the so found means of all the classes</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.predict_mdm"><code>predict_mdm</code></a></td><td style="text-align: left">predicts the class for each sample case depending on its distance from the respective means</td></tr><tr><td style="text-align: left"><a href="#RiemannianML.predict_prob"><code>predict_prob</code></a></td><td style="text-align: left">predicts the probability of each class for each sample case depending on its distance from the respective means</td></tr></table><p>For a detailed understanding of mdm, one should know the basics of Riemannian Geometry and its application in the classification of positive definite matrices. One may refer to the following papers for getting the feel of the process.</p><p>A. Barachant, S. Bonnet, M. Congedo, C. Jutten (2012) <a href="https://hal.archives-ouvertes.fr/hal-00681328/document">Multi-class Brain Computer Interface Classification by Riemannian Geometry, IEEE Transactions on Biomedical Engineering, 59(4), 920-928</a>.</p><p>A. Barachant, S. Bonnet, M. Congedo, C. Jutten (2013) <a href="https://hal.archives-ouvertes.fr/hal-00820475/document">Classification of covariance matrices using a Riemannian-based kernel for BCI applications, Neurocomputing, 112, 172-178</a>.</p><p>M. Congedo, A. Barachant, R. Bhatia R (2017a) <a href="https://bit.ly/2HOk5qN">Riemannian Geometry for EEG-based Brain-Computer Interfaces; a Primer and a Review, Brain-Computer Interfaces, 4(3), 155-174</a>.</p><p>M. Congedo, A. Barachant, E. Kharati Koopaei (2017b) <a href="https://bit.ly/2HKEcGk">Fixed Point Algorithms for Estimating Power Means of Positive Definite Matrices, IEEE Transactions on Signal Processing, 65(9), 2211-2220</a>.</p><p>Or one may directly look into the <a href="https://marco-congedo.github.io/PosDefManifold.jl/latest/introToRiemannianGeometry/">Intro to Riemannian Geometry</a> section of the PostDefManifold documentation and quench all their doubts. </p><h2><a class="nav-anchor" id="MDM-structure-1" href="#MDM-structure-1">MDM structure</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.MDM" href="#RiemannianML.MDM"><code>RiemannianML.MDM</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><p>This is a structure of the MDM model. It has two attributes namely metric and class_means.</p><ul><li><strong>metric :: Metric</strong>        :- The user needs to specify the metric space in which all the distance computations is to be done. The possible options are:</li></ul><table><tr><th style="text-align: left">Metric</th><th style="text-align: left">Mean estimation</th></tr><tr><td style="text-align: left">Euclidean</td><td style="text-align: left">distance: Œ¥_e; mean: Arithmetic</td></tr><tr><td style="text-align: left">invEuclidean</td><td style="text-align: left">distance: Œ¥_i; mean: Harmonic</td></tr><tr><td style="text-align: left">ChoEuclidean</td><td style="text-align: left">distance: Œ¥_c; mean: Cholesky Euclidean</td></tr><tr><td style="text-align: left">logEuclidean</td><td style="text-align: left">distance: Œ¥_l; mean: Log Euclidean</td></tr><tr><td style="text-align: left">logCholesky</td><td style="text-align: left">distance: Œ¥_c; mean: Log-Cholesky</td></tr><tr><td style="text-align: left">Fisher</td><td style="text-align: left">distance: Œ¥_f; mean: Fisher (Cartan, Karcher, Pusz-Woronowicz,...)</td></tr><tr><td style="text-align: left">logdet0</td><td style="text-align: left">distance: Œ¥_s; mean: LogDet (S, Œ±, Bhattacharyya, Jensen,...)</td></tr><tr><td style="text-align: left">Jeffrey</td><td style="text-align: left">distance: Œ¥_j; mean: Jeffrey (symmetrized Kullback-Leibler)</td></tr><tr><td style="text-align: left">VonNeumann</td><td style="text-align: left">distance: Œ¥_v; mean: Not Availale</td></tr><tr><td style="text-align: left">Wasserstein</td><td style="text-align: left">distance: Œ¥_w; mean: Wasserstein (Bures, Hellinger, ...)</td></tr></table><ul><li><strong>class_means</strong>             :- This is not to be specified by the user. This comes to play when                               a model is fit with a set of training data so we have to store the means corresponding                               to each of the classes. We can directly access this for an already fit model                               while using functions like predict.</li></ul></div></div></section><h2><a class="nav-anchor" id="mean_mdm-1" href="#mean_mdm-1">mean_mdm</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.mean_mdm" href="#RiemannianML.mean_mdm"><code>RiemannianML.mean_mdm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>This function is kind of an interface to the mean function of PostDefManifold for computing means for mdm classifier whith metrics other than Fisher, logdet0 and Wasserstein. For these three types of metrics specially it is an interface to their respective mean functions in PostDefManifold. Since the above three metrics do not have any closed form solution for estimating the mean, hence we follow iterative algorithms to compensate for that. As iterative algorithms are always accompanied by the question of convergence, so, in order to answer that we need a convergence check for these three metric types which is facilitated by their respective mean functions. Thereby calling them instead of the generalised mean function specifically for these three kinds of metric.</p><p>Arguments taken by this function are:</p><ul><li><strong>metric :: Metric</strong>        :-The user needs to specify the metric space in which                               all the distance computations is to be done.</li><li><strong>ùêè::‚ÑçVector</strong>              :-Vector of Hermitian matrices or simply a HermitianVector.                                    The vector of points in the <em>Symmetric Positive Definite</em>                                    manifold to be transformed into the the tangent space.</li><li><strong>w::Vector(optional)</strong>:- Vector containing weights corresponding to every point in ùêè.</li><li><strong>‚úìw = true(optional)</strong>    :- Boolean to determine whether to calculate weighted mean or just take w = [].</li><li><strong>‚è© = false (optional)</strong>   :- Boolean to allow threading or not.</li></ul><p>Return value :</p><ul><li><strong>G :: ‚Ñç</strong>                  :- Mean of the set of ‚ÑçVector.</li></ul></div></div></section><h2><a class="nav-anchor" id="find_dist-1" href="#find_dist-1">find_dist</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.find_dist" href="#RiemannianML.find_dist"><code>RiemannianML.find_dist</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>This is a function to find the distance of each sample case from the so found means of all the classes. Distance is caluclated in the metric space opted by the user while creating the instance of mdm.</p><p>Arguments taken by this function are:</p><ul><li><strong>sample :: ‚ÑçVector</strong>       :-The vector of Hermitian matrices or points in                                      the positive definite manifold for which the                                      prediction is to be made using the model(argument 1)                                      already been trained specially for it.</li><li><strong>class_means</strong>             :- Vector of Hermitian matrices that represent the class                               means or the centroid of all the classes in the training set.</li><li><strong>metric :: Metric</strong>        :-The user needs to specify the metric space in which                               all the distance computations is to be done.</li></ul><p>Return value:</p><ul><li><strong>A :: Array{Float64,2}</strong>   :- Array of distances of each of the sample case from                                   each of the class_means.</li></ul></div></div></section><h2><a class="nav-anchor" id="predict_mdm-1" href="#predict_mdm-1">predict_mdm</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.predict_mdm" href="#RiemannianML.predict_mdm"><code>RiemannianML.predict_mdm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>This is a function to predict the class for each sample case depending on its distance from the respective means. The class associated with the closest mean of the sample is alloted to that sample case. So the name comes Minimum distance to Mean as the mean which is at the minimum distance to the sample decides the class of the sample.</p><p>Arguments taken by this function are:</p><ul><li><strong>sample :: ‚ÑçVector</strong>       :- The vector of Hermitian matrices or points in                                          the positive definite manifold for which the                                          prediction is to be made using the model(argument 1)                                          already been trained specially for it.</li><li><strong>class_means</strong>             :- Vector of Hermitian matrices that represent the class                                   means or the centroid of all the classes in the training set.</li><li><strong>metric :: Metric</strong>        :- The user needs to specify the metric space in which                               all the distance computations is to be done.</li></ul><p>Return value:</p><ul><li><strong>result :: Array{Int, 1}</strong> :- The List of the predicted classes for the given                                   sample set.</li></ul></div></div></section><h2><a class="nav-anchor" id="predict_prob-1" href="#predict_prob-1">predict_prob</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML.predict_prob" href="#RiemannianML.predict_prob"><code>RiemannianML.predict_prob</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><p>This is a function to predict the probability of each class for each sample case depending on its distance from the respective means. The class associated with the closest mean is having the highest probability. All the probability sums to 1. This function makes use of the softmax function from thr PostDefManifold to calculate the probability values.</p><p>Arguments taken by this function are:</p><ul><li><strong>sample :: ‚ÑçVector</strong>       :-The vector of Hermitian matrices or points in                                          the positive definite manifold for which the probability                                          prediction is to be made using the model(argument 1)                                          already been trained specially for it.</li><li><strong>class_means</strong>             :- Vector of Hermitian matrices that represent the class                                   means or the centroid of all the classes in the training set.</li><li><strong>metric :: Metric</strong>        :-The user needs to specify the metric space in which                               all the distance computations is to be done.</li></ul><p>Return value:</p><ul><li><strong>Prob :: Array{Float64,1}</strong>:- The List of the predicted probabilities corresponding                                   to each of the classes for the given sample set.</li></ul></div></div></section><footer><hr/><a class="previous" href="../train_test/"><span class="direction">Previous</span><span class="title">train_test.jl</span></a><a class="next" href="../cross_mdm/"><span class="direction">Next</span><span class="title">cross_mdm.jl</span></a></footer></article></body></html>
