<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>train_test.jl · RiemannianML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="RiemannianML logo"/></a><h1>RiemannianML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">RiemannianML Documentation</a></li><li><a class="toctext" href="../MainModule/">MainModule (RiemannianML.jl)</a></li><li><a class="toctext" href="../knn/">knn.jl</a></li><li><a class="toctext" href="../logisticRegression/">logisticRegression.jl</a></li><li><a class="toctext" href="../SVM/">SVM.jl</a></li><li class="current"><a class="toctext" href>train_test.jl</a><ul class="internal"><li><a class="toctext" href="#logMap-1">logMap</a></li><li><a class="toctext" href="#fit!-1">fit!</a></li><li><a class="toctext" href="#predict-1">predict</a></li><li><a class="toctext" href="#cross*val*score-1">cross<em>val</em>score</a></li></ul></li><li><a class="toctext" href="../mdm/">mdm.jl</a></li><li><a class="toctext" href="../example/">example.jl</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>train_test.jl</a></li></ul><a class="edit-page" href="https://github.com/tosalonijain/RiemannianML/blob/master/docs/src/train_test.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>train_test.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="train_test.jl-1" href="#train_test.jl-1">train_test.jl</a></h1><p>This unit implements the tranformation function. Along with that this unit overwrites the fit!, predict and cross<em>val</em>score from the ScikitLearn.jl package. This enables us to use the same functions even for data in the manifold of positive definite matrices.</p><p>It imports the required machine learning models from scikit-learn python using PyCall. This unit includes the following functions :</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#logMap-1">logMap</a></td><td style="text-align: left">internal function that projects the points in the SPD manifold into the tangent space</td></tr><tr><td style="text-align: left"><a href="#ScikitLearnBase.fit!"><code>fit!</code></a></td><td style="text-align: left">fits the model for the given training set</td></tr><tr><td style="text-align: left"><a href="#ScikitLearnBase.predict"><code>predict</code></a></td><td style="text-align: left">makes prediction for the points in the test set</td></tr><tr><td style="text-align: left"><a href="#ScikitLearn.Skcore.cross_val_score"><code>cross_val_score</code></a></td><td style="text-align: left">evaluates the cross-validation score of the estimator or model</td></tr></table><h2><a class="nav-anchor" id="logMap-1" href="#logMap-1">logMap</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PosDefManifold.logMap" href="#PosDefManifold.logMap"><code>PosDefManifold.logMap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a ℍVector( Vector of Hermitian matrices), weights(optional), returns a vector containing the mapping of these matrices in the tangent space of the data set mean. Vectorization is done along with the mapping. The relation employed for mapping is the following logarithmic relation:         <span>$(G½ * log(ℍ(G⁻½ * 𝐏[i] * G⁻½)) * G½)$</span> where G is the data set mean and 𝐏[i] the set of points to be mapped. For the better understanding of this mapping, one may refer to the <a href="https://marco-congedo.github.io/PosDefManifold.jl/latest/riemannianGeometry/#PosDefManifold.logMap">logMap function in PostDefManifold</a>.</p><p>Arguments:</p><ul><li><code>𝐏::ℍVector</code>              :- Vector of Hermitian matrices or simply a HermitianVector.                                    The vector of points in the <em>Symmetric Positive Definite</em>                                    manifold to be transformed into the the tangent space.</li></ul><p><em>The following parameters are needed for mean computation only:</em></p><ul><li><code>w::Vector(optional)</code>:- Vector containing weights corresponding to every point                                    in 𝐏.</li><li><code>✓w = true(optional)</code>     :- Boolean to determine whether to calculate weighted mean                                    or just take w = []. It also checks if the weights                                    sum up to 1. If not does normalization.</li><li><code>⏩ = false (optional)</code>    :- Boolean to allow threading or not.</li></ul><p>Returns:</p><ul><li><code>Vec :: Array{Float64, 2}</code> :-Vector of all the points in the training set.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/train_test.jl#L2-L31">source</a></section><h2><a class="nav-anchor" id="fit!-1" href="#fit!-1">fit!</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScikitLearnBase.fit!" href="#ScikitLearnBase.fit!"><code>ScikitLearnBase.fit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a model, ℍVector(training set), y(labels), weights(optional), checks the type of model and then fits the model to the given training set. This function is an overwriting of the default fit! function available in the ScikitLearn.jl package. The function also prints the average regular score for all models except mdm.</p><p>Arguments :</p><ul><li><p><code>model::RiemannianML object</code>:- Classifier model instance eg. kneighbhorClf(),                                  LogisticReg() or others. The model which is to                                  be trained or to which the given data is to be fit.                                  The instance should be created before calling fit! to                                  train it.</p></li><li><p><code>𝐗::ℍVector</code>               :- Vector of Hermitian matrices or simply a HermitianVector.                                 The vector of points in the training set consisting of                                 <em>Symmetric Positive Definite</em> manifold matrices.</p></li><li><p><code>y :: Int[]</code>               :- Vector of intrger labels corresponding to each sample in the                                 training set.</p></li><li><p><code>w::Vector(optional)</code> :- Vector containing weights corresponding to every point                                 in 𝐗. <em>Only for mdm models.</em></p></li><li><p><code>✓w = true(optional)</code>      :- Boolean to determine whether to calculate weighted mean                                 or just take w = [].It also checks if the weights                                 sum up to 1. If not does normalization.</p></li></ul><p>Returns: (A value is returned only in case the model is an mdm object)</p><ul><li><code>class_means</code>              :- List of means corresponding to all the classes for the                                   given training set.</li></ul><pre><code class="language-none">## Example
model1 = kneighborClf(n_neighbors=3)
model2 = LogisticReg()
model3 = MDM(Fisher)
𝐗 = *load data...*
y = *load labels...*
fit!(model1, 𝐗,y)
fit!(model2, 𝐗,y)
fit!(model3, 𝐗,y)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/train_test.jl#L44-L87">source</a></section><h2><a class="nav-anchor" id="predict-1" href="#predict-1">predict</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScikitLearnBase.predict" href="#ScikitLearnBase.predict"><code>ScikitLearnBase.predict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a trained model and the sample set, gives the predicted class for the data points in the sample set. This function is an overwriting of the default predict function available in the ScikitLearn.jl package.</p><p>Arguments :</p><ul><li><code>model::RiemannianML object</code>:- Classifier model instance eg. kneighbhorClf(),                                      LogisticReg() or others. The model which is already                                      been trained according to a training set can only be                                      used as an argument here. The instance should be                                      created and fit before calling predict on it.</li><li><code>samp::ℍVector</code>             :- The vector of Hermitian matrices or points in                                      the positive definite manifold for which the                                      prediction is to be made using the model(argument 1)                                      already been trained specially for it.</li></ul><p>Returns :</p><ul><li><code>Predicted classes</code>        :- The List of the predicted classes for the given                                   sample set.</li></ul><pre><code class="language-none">## Example
# following the above code for fit!
predict(model1, 𝐗)
predict(model2, 𝐗)
predict(model3, 𝐗)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/train_test.jl#L107-L137">source</a></section><h2><a class="nav-anchor" id="cross*val*score-1" href="#cross*val*score-1">cross<em>val</em>score</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScikitLearn.Skcore.cross_val_score" href="#ScikitLearn.Skcore.cross_val_score"><code>ScikitLearn.Skcore.cross_val_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Given a model, ℍVector(training set), y(labels), cv(number of cross-validations) returns the the list containing the score for each cross-validation iteration. This function is an overwriting of the default cross<em>val</em>score function available in the ScikitLearn.jl package.</p><p>Arguments :</p><ul><li><code>model::RiemannianML object</code>:- Classifier model instance eg. kneighbhorClf(),                                      LogisticReg() or others i,e. the model whose                                      evaluation using cross-validation is to be done.</li><li><code>𝐗::ℍVector</code>                :- Vector of Hermitian matrices or simply a HermitianVector.                                      The vector of points in the training set consisting of                                      <em>Symmetric Positive Definite</em> manifold matrices. The                                      training set on the basis of which the evaluation                                      of the given model is to be done.</li><li><code>y :: Int[]</code>                :- Vector of intrger labels corresponding to each sample in the                                      training set.</li><li><code>cv :: Int(optional)</code>       :- The number of cross-validation desired by the user.                                      The default value is set to 5.</li></ul><p><em>These arguments are only applicable if the model is mdm type</em> :</p><ul><li><code>scoring :: String</code>      :- If Balanced Accuracy is requied or the Regular Accuracy.                                   The default is set to Balanced Accuracy.</li><li><code>cnfmat :: Bool</code>         :- Boolean to notify if the user wants the confusion matrix also.                              Default is set to false.</li></ul><p>Returns :</p><ul><li><code>cross_val score</code>          :- The list containing the score for each cross_val                                   iteration.</li></ul><pre><code class="language-none">   ## Example
   model1 = kneighborClf(n_neighbors=3)
   model2 = LogisticReg()
   model3 = MDM(Fisher)
   𝐗 = *load data...*
   y = *load labels...*
   println(cross_val_score(model1,𝐗,y))
   println(cross_val_score(model2,𝐗,y))
   cross_val_score(model5, 𝐗,y)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/tosalonijain/RiemannianML/blob/f44d226244823a847e899f37556c0ab64717c544/src/train_test.jl#L147-L192">source</a></section><footer><hr/><a class="previous" href="../SVM/"><span class="direction">Previous</span><span class="title">SVM.jl</span></a><a class="next" href="../mdm/"><span class="direction">Next</span><span class="title">mdm.jl</span></a></footer></article></body></html>
