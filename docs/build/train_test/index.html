<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>train_test.jl · RiemannianML</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RiemannianML</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">RiemannianML Documentation</a></li><li><a class="toctext" href="../MainModule/">MainModule (RiemannianML.jl)</a></li><li><a class="toctext" href="../knn/">knn.jl</a></li><li><a class="toctext" href="../logisticRegression/">logisticRegression.jl</a></li><li><a class="toctext" href="../SVM/">SVM.jl</a></li><li class="current"><a class="toctext" href>train_test.jl</a><ul class="internal"><li><a class="toctext" href="#*transform*ts-1"><em>transform</em>ts</a></li><li><a class="toctext" href="#fit!-1">fit!</a></li><li><a class="toctext" href="#predict-1">predict</a></li><li><a class="toctext" href="#cross*val*score-1">cross<em>val</em>score</a></li></ul></li><li><a class="toctext" href="../mdm/">mdm.jl</a></li><li><a class="toctext" href="../cross_mdm/">cross_mdm.jl</a></li><li><a class="toctext" href="../example/">example.jl</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>train_test.jl</a></li></ul></nav><hr/><div id="topbar"><span>train_test.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="train_test.jl-1" href="#train_test.jl-1">train_test.jl</a></h1><p>This unit implements the tranformation function. Along with that this unit overwrites the fit!, predict and cross<em>val</em>score from the ScikitLearn.jl package. This enables us to use the same functions even for data in the manifold of positive definite matrices.</p><p>It imports the required machine learning models from scikit-learn python using PyCall. This unit includes the following functions :</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#*transform*ts-1"><em>transform</em>ts</a></td><td style="text-align: left">internal function that projects the points in the SPD manifold into the tangent space</td></tr><tr><td style="text-align: left"><a href="#ScikitLearnBase.fit!"><code>fit!</code></a></td><td style="text-align: left">fits the model for the given training set</td></tr><tr><td style="text-align: left"><a href="#ScikitLearnBase.predict"><code>predict</code></a></td><td style="text-align: left">makes prediction for the points in the test set</td></tr><tr><td style="text-align: left"><a href="#ScikitLearn.Skcore.cross_val_score"><code>cross_val_score</code></a></td><td style="text-align: left">evaluates the cross-validation score of the estimator or model</td></tr></table><h2><a class="nav-anchor" id="*transform*ts-1" href="#*transform*ts-1"><em>transform</em>ts</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RiemannianML._transform_ts" href="#RiemannianML._transform_ts"><code>RiemannianML._transform_ts</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This is an internal function which performs the transformation of data from the manifold of positive definite matrices to the eucledian space of the data set mean. We find the mean of the entire data set with the help of the mean function from PostDefManifold. Once the mean is speculated we do the transformation of all the data points to their corresponding values in the tangent space of the data set mean. The relation employed for transformation is the following logarithmic relation:         (G½ * log(ℍ(G⁻½ * 𝐏[i] * G⁻½)) * G½) where G is the data set mean and 𝐏[i] the set of points to be transformed. For the better understanding of this transformation, one may refer to the papers.</p><p>Arguments taken by this function are:</p><ul><li><strong>𝐏::ℍVector</strong>              :- Vector of Hermitian matrices or simply a HermitianVector.                                    The vector of points in the <em>Symmetric Positive Definite</em>                                    manifold to be transformed into the the tangent space.</li><li><strong>w::Vector(optional)</strong>:- Vector containing weights corresponding to every point                                    in 𝐏.</li><li><strong>✓w = true(optional)</strong>     :- Boolean to determine whether to calculate weighted mean                                    or just take w = [].</li><li><strong>⏩ = false (optional)</strong>    :- Boolean to allow threading or not.</li></ul><p>Return Value:</p><ul><li><strong>Vec :: Array{Float64, 2}</strong> :-Vector of all the points in the training set.</li></ul></div></div></section><h2><a class="nav-anchor" id="fit!-1" href="#fit!-1">fit!</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScikitLearnBase.fit!" href="#ScikitLearnBase.fit!"><code>ScikitLearnBase.fit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function is an overwriting of the default fit! function available in the ScikitLearn.jl package. It checks the type of model, if it is mdm it runs a block of code that fits the data which is in positive definite matrices manifold directly by finding mean of datasets from all the classes. This mean list is stored in the class<em>means attribute of the mdm instance. If the model is not of type mdm, it takes a different and simpler path. Then the function just calls the internal function _transform</em>ts to make the transformation into the tangent space. This tangent space behaves like an eucledian space. So, now the default fit! of ScikitLearn.jl can directly be put to use. The function also prints the average regular score in this case.</p><p>Arguments taken by this function are:</p><ul><li><p><strong>model::RiemannianML object</strong>:- Classifier model instance eg. kneighbhorClf(),                                  LogisticReg() or others. The model which is to                                  be trained or to which the given data is to be fit.                                  The instance should be created before calling fit! to                                  train it.</p></li><li><p><strong>𝐗::ℍVector</strong>               :- Vector of Hermitian matrices or simply a HermitianVector.                                 The vector of points in the training set consisting of                                 <em>Symmetric Positive Definite</em> manifold matrices.</p></li><li><p><strong>y :: Int[]</strong>               :- Vector of intrger labels corresponding to each sample in the                                 training set.</p></li><li><p><strong>w::Vector(optional)</strong> :- Vector containing weights corresponding to every point                                 in 𝐗.</p></li><li><p><strong>✓w = true(optional)</strong>      :- Boolean to determine whether to calculate weighted mean                                 or just take w = [].</p></li></ul><p>A value is returned only in case the model is an mdm object. The return value in that case:</p><ul><li><strong>class_means</strong>              :- List of means corresponding to all the classes for the                                   given training set.</li></ul><pre><code class="language-none">## Example
model1 = kneighborClf(n_neighbors=3)
model2 = LogisticReg()
model3 = MDM(Fisher)
n=10
k1=25
k2=25
k=k1+k2
A1=randP(n)
A2=randP(n)
P=randP(n, k1+k2)
gm=0.5
P2=[geodesic(Fisher, P[i], A1, gm) for i=1:k1]
Q2=[geodesic(Fisher, P[i], A2, gm) for i=k1+1:k1+k2 ]
𝐗=ℍVector([P2; Q2])
Y = ones(Int64, 50)
for j = 25:50
    Y[j] = 2
end
fit!(model1, 𝐗,Y)
fit!(model2, 𝐗,Y)
fit!(model3, 𝐗,Y)</code></pre></div></div></section><h2><a class="nav-anchor" id="predict-1" href="#predict-1">predict</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScikitLearnBase.predict" href="#ScikitLearnBase.predict"><code>ScikitLearnBase.predict</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function is an overwriting of the default predict function available in the ScikitLearn.jl package. It works similar to the above fit! function. Depending on the type of model i.e. mdm or rest, two different paths are opted. If its mdm, then the predict<em>mdm function from the mdm.jl unit is called that helps in making the prediction. If its not of type mdm, the function just calls the internal function _transform</em>ts to make the transformation into the tangent space. This tangent space behaves like an eucledian space. So, now the default predict of ScikitLearn.jl can directly be put to use.</p><p><em>Arguments taken by this function are:</em></p><ul><li><strong>model::RiemannianML object</strong>:- Classifier model instance eg. kneighbhorClf(),                                      LogisticReg() or others. The model which is already                                      been trained according to a training set can only be                                      used as an argument here. The instance should be                                      created and fit before calling predict on it.</li><li><strong>samp::ℍVector</strong>             :- The vector of Hermitian matrices or points in                                      the positive definite manifold for which the                                      prediction is to be made using the model(argument 1)                                      already been trained specially for it.</li></ul><p><em>Return value:</em></p><ul><li><strong>Predicted classes</strong>        :- The List of the predicted classes for the given                                   sample set.</li></ul><pre><code class="language-none">## Example
# following the above code for fit!
predict(model1, 𝐗)
predict(model2, 𝐗)
predict(model3, 𝐗)</code></pre></div></div></section><h2><a class="nav-anchor" id="cross*val*score-1" href="#cross*val*score-1">cross<em>val</em>score</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ScikitLearn.Skcore.cross_val_score" href="#ScikitLearn.Skcore.cross_val_score"><code>ScikitLearn.Skcore.cross_val_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function is an overwriting of the default cross<em>val</em>score function available in the ScikitLearn.jl package. It works similar to the above mentioned fit! and predict functions. Depending on the type of model i.e. mdm or rest, two different paths are opted. If its mdm, then the cross<em>val</em>mdm function from the cross<em>mdm.jl unit is called that helps in doing cross-validation evaluation. If its not of type mdm, the function just calls the internal function _transform</em>ts to make the transformation into the tangent space. This tangent space behaves like an eucledian space. So, now the default cross<em>val</em>score of ScikitLearn.jl can directly be put to use.</p><p>Arguments taken by this function are:</p><ul><li><strong>model::RiemannianML object</strong>:- Classifier model instance eg. kneighbhorClf(),                                      LogisticReg() or others i,e. the model whose                                      evaluation using cross-validation is to be done.</li><li><strong>𝐗::ℍVector</strong>                :- Vector of Hermitian matrices or simply a HermitianVector.                                      The vector of points in the training set consisting of                                      <em>Symmetric Positive Definite</em> manifold matrices. The                                      training set on the basis of which the evaluation                                      of the given model is to be done.</li><li><strong>y :: Int[]</strong>                :- Vector of intrger labels corresponding to each sample in the                                      training set.</li><li><strong>cv :: Int(optional)</strong>       :- The number of cross-validation desired by the user.                                      The default value is set to 5.</li></ul><p><em>Return value</em>:</p><ul><li><strong>cross_val score</strong>          :- The list containing the score for each cross_val                                   iteration.</li></ul><pre><code class="language-none">   ## Example
   model1 = kneighborClf(n_neighbors=3)
   model2 = LogisticReg()
   model3 = MDM(Fisher)
   n=10
   k1=25
   k2=25
   k=k1+k2
   A1=randP(n)
   A2=randP(n)
   P=randP(n, k1+k2)
   gm=0.5
   P2=[geodesic(Fisher, P[i], A1, gm) for i=1:k1]
   Q2=[geodesic(Fisher, P[i], A2, gm) for i=k1+1:k1+k2 ]
   𝐗=ℍVector([P2; Q2])
   Y = ones(Int64, 50)
   for j = 25:50
       Y[j] = 2
   end
   println(cross_val_score(model1,𝐗,Y))
   println(cross_val_score(model2,𝐗,Y))
   cross_val_score(model5, 𝐗,Y)</code></pre></div></div></section><footer><hr/><a class="previous" href="../SVM/"><span class="direction">Previous</span><span class="title">SVM.jl</span></a><a class="next" href="../mdm/"><span class="direction">Next</span><span class="title">mdm.jl</span></a></footer></article></body></html>
